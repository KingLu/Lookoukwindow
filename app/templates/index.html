{% extends "base.html" %}

{% block title %}Lookoukwindow - ä»·å€¼æŠ•èµ„å±{% endblock %}

{% block content %}
<!-- å·¦ä¾§é¢æ¿ï¼šç»¼åˆä¿¡æ¯(ä¸Š) + ç›´æ’­(ä¸­) + é‡‘è(ä¸‹) -->
<div class="main-content dashboard-left">
    <!-- ä¸Šéƒ¨ï¼šç»¼åˆç”Ÿæ´»ä¿¡æ¯æ  (ç´§å‡‘) -->
    <div class="dashboard-top">
        <div class="info-left">
            <div class="date-time-group">
                <div class="date-compact">
                    <span id="date-solar">2025/01/01 å‘¨ä¸€</span>
                    <span id="date-lunar-ganzhi" style="font-size: 0.85em; color: #aaa; margin-left: 10px;">è…Šæœˆåˆå…« ä¹™å·³å¹´</span>
                </div>
                <div class="time-display-compact" id="time-display" onclick="toggleTimeFormat()">00:00:00</div>
            </div>
        </div>
        <div class="info-right">
            <div class="weather-container">
                <div class="weather-current">
                    <div id="weather-icon" style="font-size: 2.5rem;">ğŸŒ¤ï¸</div>
                    <div class="weather-text">
                        <div id="weather-temp" style="font-weight: bold; font-size: 1.5rem;">--Â°C</div>
                        <div id="weather-location" style="font-size: 0.8rem; color: #aaa;">{{ weather_config.get('location_name', 'åŒ—äº¬å¸‚') }}</div>
                    </div>
                </div>
                <!-- æœªæ¥3å°æ—¶é¢„æŠ¥ -->
                <div class="weather-forecast" id="weather-forecast">
                    <!-- åŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>
        </div>
    </div>

    <!-- ä¸­éƒ¨ï¼šç›´æ’­ (Flex grow è‡ªåŠ¨å¡«å……) -->
    <div class="youtube-container">
        <div id="youtube-loading" style="display: flex; align-items: center; justify-content: center; height: 100%; color: #fff;">
            <div>æ­£åœ¨åŠ è½½NASAç›´æ’­...</div>
        </div>
        <iframe 
            id="youtube-iframe"
            class="youtube-iframe"
            src=""
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share; unload"
            allowfullscreen
            referrerpolicy="strict-origin-when-cross-origin"
            frameborder="0"
            title="YouTube video player"
            style="display: none;">
        </iframe>
    </div>

    <!-- ä¸‹éƒ¨ï¼šé‡‘èä¿¡æ¯é¢æ¿ (ä»·å€¼æŠ•èµ„ç‰ˆ - æç®€ç´§å‡‘) -->
    <div class="dashboard-bottom-finance">
        <!-- 1. æŒ‡æ•°æ  (æ— ç¼æ»šåŠ¨è·‘é©¬ç¯) - ä¿æŒä¸å˜ -->
        <div class="indices-ticker" id="indices-container">
            <div class="loading-text" style="padding: 10px; color: #999;">åŠ è½½æŒ‡æ•°æ•°æ®...</div>
        </div>
        
        <!-- 2. ä¸ªè‚¡è½®æ’­ (é‡æ„ä¸ºä»·å€¼ä»ªè¡¨ç›˜) -->
        <div class="stock-carousel" id="stock-carousel">
            <!-- å·¦ä¾§ï¼šåŸºæœ¬ä¿¡æ¯ + ä¼°å€¼ä»ªè¡¨ç›˜ -->
            <div class="stock-value-panel">
                <!-- 1. Name & Change Row -->
                <div class="stock-row-header">
                     <div class="stock-name-wrapper">
                         <span id="stock-name" class="stock-name">--</span>
                         <span id="stock-type-badge" class="stock-badge">--</span>
                     </div>
                     <span id="stock-change" class="stock-change">--</span>
                </div>

                <!-- 2. Main Data Row (Symbol - Price - Target Unified) -->
                <div class="stock-row-main">
                    <!-- è‚¡ç¥¨ä»£ç  -->
                    <div class="col-symbol" id="stock-symbol">--</div>
                    
                    <!-- å½“å‰ä»·æ ¼ -->
                    <div class="col-price" id="stock-price">--</div>
                    
                    <!-- ç›®æ ‡ä»·æ ¼ (åŠ¨æ€) -->
                    <div class="col-target">
                         <span id="target-label" class="label-mini">ç›®æ ‡</span>
                         <div class="target-val-group">
                             <span id="metric-target-val" class="target-val">--</span>
                             <span id="metric-target-diff" class="target-diff">--</span>
                         </div>
                    </div>
                </div>

                <!-- 3. Holding Row (Conditional) -->
                <div id="holding-info-row" class="stock-row-holding" style="display:none;">
                    <span class="label-mini">æŒä»“æ”¶ç›Š:</span>
                    <div style="display:flex; align-items:baseline; gap:5px;">
                        <span id="metric-holding-gain" style="font-weight:bold; font-size:0.9rem;">--</span>
                        <span id="metric-holding-percent" style="font-size:0.75rem;">--</span>
                    </div>
                </div>

                <!-- 4. Extra Info Grid (Compact) -->
                <div class="stock-grid-extra">
                     <div>52å‘¨: <span id="metric-year-range">--</span></div>
                     <div>é‡: <span id="metric-volume">--</span></div>
                     <div>å‰æ”¶: <span id="metric-prev-close">--</span></div>
                     <div id="metric-analyst-container" style="display:none;">åˆ†æ: <span id="metric-analyst-target">--</span></div>
                     <div id="metric-earnings-container" style="display:none;">è´¢æŠ¥: <span id="metric-earnings">--</span></div>
                </div>

                <!-- Gauge -->
                <div class="price-gauge-container">
                    <div class="gauge-track">
                        <div id="gauge-bar" class="gauge-bar"></div>
                        <div id="gauge-marker-buy" class="gauge-marker buy"></div>
                        <div id="gauge-marker-sell" class="gauge-marker sell"></div>
                        <div id="gauge-cursor" class="gauge-cursor"></div>
                    </div>
                    <div class="gauge-label-row">
                        <span style="color: #2ecc71; font-size: 0.65rem;">ä½ä¼°</span>
                        <span style="color: #e74c3c; font-size: 0.65rem;">é«˜ä¼°</span>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§ï¼šå‘¨æœŸè¶‹åŠ¿å›¾ (3å¹´å‘¨çº¿) -->
            <div class="stock-chart-panel">
                <div class="chart-box">
                    <div class="chart-label">3å¹´å‘¨çº¿ (å‘¨æœŸè¶‹åŠ¿) + MA50</div>
                    <canvas id="stockChartCycle"></canvas>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- å³ä¾§é¢æ¿ï¼šç›¸å†Œ -->
<div class="sidebar">
    <div class="photo-container" id="photo-container">
        <div class="loading">åŠ è½½ä¸­...</div>
    </div>
</div>

<!-- Sleep Mode Overlay -->
<div id="sleep-overlay" style="display: none;">
    <div class="sleep-content">
        <div id="sleep-date-full" style="font-size: 1.8rem; color: #555; margin-bottom: 10px;">2025å¹´01æœˆ01æ—¥ æ˜ŸæœŸä¸€</div>
        <div id="sleep-time" style="font-size: 10rem; font-weight: bold; font-family: 'Segoe UI', sans-serif; color: #333; line-height: 1;">00:00:00</div>
        <div id="sleep-lunar" style="font-size: 1.5rem; color: #444; margin-top: 15px;">è…Šæœˆåˆå…« ä¹™å·³å¹´ [è›‡å¹´]</div>
    </div>
</div>
{% endblock %}

{% block extra_css %}
<style>
    /* ... existing sleep and layout styles ... */
    /* Sleep Overlay */
    #sleep-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background-color: #000;
        z-index: 9999;
        display: none;
        align-items: center;
        justify-content: center;
        cursor: none; 
    }
    
    .sleep-content {
        text-align: center;
        color: #333; 
        transition: transform 1s ease-in-out; 
    }
    
    #sleep-time {
        font-size: 10rem;
        font-weight: bold;
        font-family: "Segoe UI", monospace;
        color: #444;
    }
    
    #sleep-date-full { font-size: 2rem; color: #222; }
    #sleep-lunar { font-size: 1.5rem; color: #333; }

    /* å¸ƒå±€é‡æ„ */
    .dashboard-left {
        display: flex;
        flex-direction: column;
        background-color: #000;
        height: 100%;
    }

    /* Top Info Bar */
    .dashboard-top {
        flex: 0 0 auto;
        padding: 10px 25px;
        background: linear-gradient(to bottom, rgba(40,40,40,0.95), rgba(20,20,20,0.8));
        color: #fff;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid rgba(255,255,255,0.1);
    }

    .info-left { display: flex; align-items: center; }
    .date-time-group { display: flex; flex-direction: column; justify-content: center; }
    .date-compact { font-size: 1.0rem; margin-bottom: 0; color: #ddd; }
    .time-display-compact {
        font-size: 2.8rem; 
        font-weight: 700;
        font-family: "Segoe UI", Roboto, monospace;
        line-height: 1;
        cursor: pointer;
        letter-spacing: 1px;
    }

    .info-right { display: flex; align-items: center; }
    .weather-container { display: flex; align-items: center; gap: 20px; }
    .weather-current { display: flex; align-items: center; gap: 10px; text-align: right; }
    .weather-forecast {
        display: flex; gap: 10px;
        border-left: 1px solid rgba(255,255,255,0.2);
        padding-left: 15px;
    }
    .forecast-item {
        display: flex; flex-direction: column;
        align-items: center; justify-content: center;
        font-size: 0.8rem; color: #ccc;
    }
    .forecast-time { font-size: 0.7rem; margin-bottom: 2px; }
    .forecast-icon { font-size: 1.2rem; margin-bottom: 2px; }

    /* Mid Video */
    .youtube-container {
        flex: 1; width: 100%; position: relative;
        display: flex; justify-content: center; align-items: center;
        background: #000; overflow: hidden;
    }
    .youtube-iframe {
        aspect-ratio: 16/9; width: 100%; height: auto;
        max-height: 100%; max-width: 100%; 
    }

    /* Bottom Finance - Value Investing Style */
    .dashboard-bottom-finance {
        flex: 0 0 28%; /* ç¨å¾®å‡å°‘é«˜åº¦å æ¯” */
        min-height: 160px; /* é™ä½æœ€å°é«˜åº¦ */
        background: linear-gradient(to top, rgba(30,30,30,0.95), rgba(10,10,10,0.9));
        border-top: 1px solid rgba(255,255,255,0.1);
        padding: 5px 0; /* å‡å°‘å†…è¾¹è· */
        display: flex; flex-direction: column; gap: 2px;
        overflow: hidden;
    }

    /* Indices Ticker - æŒ‡æ•°å¡ç‰‡è·‘é©¬ç¯ (å¢å¼ºç‰ˆ) */
    .indices-ticker {
        width: 100%; overflow: hidden; position: relative; padding: 0 15px;
        mask-image: linear-gradient(to right, transparent, black 2%, black 98%, transparent);
        -webkit-mask-image: linear-gradient(to right, transparent, black 2%, black 98%, transparent);
        margin-bottom: 2px; flex: 0 0 auto;
    }
    .indices-track { display: flex; gap: 12px; width: max-content; animation: marquee 60s linear infinite; }
    .indices-track:hover { animation-play-state: paused; }
    @keyframes marquee { 0% { transform: translateX(0); } 100% { transform: translateX(-50%); } }
    
    /* æŒ‡æ•°å¡ç‰‡ - è¯¦ç»†ä¿¡æ¯å±•ç¤º */
    .index-card {
        background: linear-gradient(135deg, rgba(40,40,45,0.95), rgba(30,30,35,0.9));
        padding: 8px 12px; border-radius: 8px;
        min-width: 160px; display: flex; flex-direction: row; align-items: center; 
        flex-shrink: 0; gap: 10px;
        border: 1px solid rgba(255,255,255,0.08);
        box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .index-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    
    /* å·¦ä¾§ï¼šæ–‡å­—ä¿¡æ¯ */
    .index-info {
        display: flex; flex-direction: column; gap: 2px; min-width: 80px;
    }
    .index-name { 
        font-size: 0.75rem; color: #ccc; white-space: nowrap; font-weight: 500;
        letter-spacing: 0.5px;
    }
    .index-price { 
        font-size: 1.1rem; font-weight: 700; line-height: 1.1;
        font-family: 'Segoe UI', 'SF Pro Display', sans-serif;
    }
    .index-change-row {
        display: flex; gap: 6px; align-items: baseline;
    }
    .index-change-val { font-size: 0.7rem; font-weight: 500; }
    .index-change-pct { font-size: 0.7rem; font-weight: 600; }
    
    /* å³ä¾§ï¼šè¿·ä½ è¶‹åŠ¿å›¾ */
    .index-chart-box {
        width: 60px; height: 35px; flex-shrink: 0;
    }
    .index-chart-box canvas {
        width: 100% !important; height: 100% !important;
    }
    
    /* æ¶¨è·Œé¢œè‰² - ä¸­å›½è‚¡å¸‚æƒ¯ä¾‹ï¼šçº¢æ¶¨ç»¿è·Œ */
    .up { color: #e74c3c; }
    .down { color: #2ecc71; }
    .up-bg { background: rgba(231, 76, 60, 0.15); border-color: rgba(231, 76, 60, 0.3); }
    .down-bg { background: rgba(46, 204, 113, 0.15); border-color: rgba(46, 204, 113, 0.3); }

    /* Stock Carousel - Value Investing Layout (Compact) */
    .stock-carousel {
        flex: 1;
        display: flex; gap: 10px;
        background: rgba(0,0,0,0.3);
        border-radius: 8px;
        padding: 5px 10px; /* æ›´ç´§å‡‘çš„å†…è¾¹è· */
        margin: 0 15px 5px 15px; 
        align-items: stretch; overflow: hidden;
        position: relative; transition: box-shadow 0.5s ease;
    }
    .stock-carousel.status-buy-zone {
        box-shadow: inset 0 0 20px rgba(255, 215, 0, 0.3); border: 1px solid rgba(255, 215, 0, 0.3);
    }
    .stock-carousel.status-sell-zone {
        box-shadow: inset 0 0 20px rgba(231, 76, 60, 0.3); border: 1px solid rgba(231, 76, 60, 0.3);
    }

    /* Left Panel: Metrics & Gauge */
    .stock-value-panel {
        flex: 0 0 40%;
        display: flex; flex-direction: column; justify-content: space-between;
    }

    /* Row 1: Header */
    .stock-row-header {
        display: flex; justify-content: space-between; align-items: flex-start;
        margin-bottom: 0;
    }
    .stock-name-wrapper { display: flex; align-items: center; gap: 5px; }
    .stock-name { font-size: 1.1rem; font-weight: bold; color: #fff; line-height: 1.1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 120px; }
    .stock-badge { 
        display: inline-block; font-size: 0.6rem; padding: 0 4px; border-radius: 3px; height: 16px; line-height: 16px;
    }
    .badge-holding { background: rgba(230, 126, 34, 0.3); color: #e67e22; border: 1px solid rgba(230, 126, 34, 0.5); }
    .badge-watching { background: rgba(52, 152, 219, 0.3); color: #3498db; border: 1px solid rgba(52, 152, 219, 0.5); }
    .stock-change { font-size: 0.8rem; }

    /* Row 2: Main Data (Symbol | Price | Target) */
    .stock-row-main {
        display: flex;
        align-items: baseline; /* åŸºçº¿å¯¹é½ */
        justify-content: space-between;
        border-bottom: 1px solid rgba(255,255,255,0.1);
        padding-bottom: 2px;
        margin-bottom: 2px;
    }
    .col-symbol { color: #888; font-size: 0.75rem; font-family: monospace; flex: 0 0 auto; }
    .col-price { font-size: 1.5rem; font-weight: 700; line-height: 1; flex: 1; text-align: center; }
    .col-target { text-align: right; flex: 0 0 auto; display: flex; flex-direction: column; align-items: flex-end; }
    
    .target-val-group { display: flex; flex-direction: column; align-items: flex-end; }
    .target-val { font-size: 1.0rem; font-weight: 600; color: #eee; line-height: 1; }
    .target-diff { font-size: 0.7rem; }

    .label-mini { font-size: 0.6rem; color: #aaa; }

    /* Row 3: Holding (Conditional) */
    .stock-row-holding {
        display: flex; justify-content: space-between; align-items: center;
        background: rgba(255,255,255,0.05);
        padding: 2px 6px;
        border-radius: 3px;
        margin-bottom: 2px;
    }

    /* Row 4: Extra Grid */
    .stock-grid-extra {
        display: grid; grid-template-columns: 1fr 1fr; gap: 1px 5px;
        font-size: 0.65rem; color: #aaa; 
        margin-bottom: 2px; 
    }
    .stock-grid-extra > div span { color: #ddd; }

    /* Gauge */
    .price-gauge-container { margin-top: auto; padding-top: 2px; }
    .gauge-label-row { display: flex; justify-content: space-between; font-size: 0.6rem; margin-top: 1px; }
    .gauge-track { height: 4px; background: #333; border-radius: 2px; position: relative; }
    .gauge-bar {
        position: absolute; left: 0; top: 0; bottom: 0; right: 0; border-radius: 2px;
        background: linear-gradient(90deg, rgba(46,204,113,0.3) 0%, rgba(46,204,113,0.1) 30%, rgba(231,76,60,0.1) 70%, rgba(231,76,60,0.3) 100%);
    }
    .gauge-marker { position: absolute; top: -1px; bottom: -1px; width: 2px; z-index: 2; }
    .gauge-marker.buy { background: #2ecc71; }
    .gauge-marker.sell { background: #e74c3c; }
    .gauge-cursor {
        position: absolute; top: -2px; bottom: -2px; width: 3px; background: #fff;
        box-shadow: 0 0 3px rgba(255,255,255,0.8); z-index: 3; border-radius: 1px; transition: left 0.5s ease;
    }
    
    /* Chart Styles */
    .stock-chart-panel { flex: 1; display: flex; min-width: 0; }
    .chart-box { flex: 1; position: relative; background: rgba(255,255,255,0.03); border-radius: 4px; padding: 2px; min-width: 0; }
    .chart-label { position: absolute; top: 3px; left: 5px; font-size: 8px; color: #888; pointer-events: none; z-index: 1; }

    /* Photo Styles ... unchanged ... */
    /* ... (copy existing photo styles) ... */
    .photo-container { position: relative; width: 100%; height: 100%; background: #000; display: flex; align-items: center; justify-content: center; }
    .photo-metadata { position: absolute; bottom: 20px; left: 20px; right: 20px; background: rgba(0, 0, 0, 0.7); padding: 15px; border-radius: 8px; font-size: 14px; z-index: 200; color: #fff; display: block; opacity: 1; pointer-events: none; }
    .meta-icon-img { width: 18px; height: 18px; vertical-align: text-bottom; margin-right: 6px; opacity: 0.9; }
    .photo-nav { position: absolute; top: 50%; transform: translateY(-50%); background: rgba(0, 0, 0, 0.5); border: none; color: #fff; font-size: 24px; padding: 20px 15px; cursor: pointer; z-index: 100; transition: background 0.2s; }
    .photo-nav:hover { background: rgba(0, 0, 0, 0.8); }
    .photo-nav.prev { left: 20px; }
    .photo-nav.next { right: 20px; }
    .hidden { display: none !important; }
    .error { color: #ff4444; padding: 20px; text-align: center; }
    .photo-wrapper { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background: #000; opacity: 0; transition: opacity 1s ease; z-index: 1; }
    .photo-wrapper.active { opacity: 1; z-index: 10; }
    .photo-wrapper.exit { opacity: 0; z-index: 5; }
    .effect-fade.enter { opacity: 0; }
    .effect-fade.active { opacity: 1; transition: opacity 1s; }
    .effect-fade.exit { opacity: 0; transition: opacity 1s; }
    .effect-slide-left.enter { transform: translateX(100%); opacity: 1; }
    .effect-slide-left.active { transform: translateX(0); opacity: 1; transition: transform 1s ease-in-out; }
    .effect-slide-left.exit { transform: translateX(-100%); opacity: 1; transition: transform 1s ease-in-out; }
    .effect-zoom.enter { transform: scale(1.2); opacity: 0; }
    .effect-zoom.active { transform: scale(1); opacity: 1; transition: all 1.2s ease; }
    .effect-zoom.exit { transform: scale(0.8); opacity: 0; transition: all 1.2s ease; }
    .effect-push.enter { transform: translateY(100%); opacity: 1; }
    .effect-push.active { transform: translateY(0); opacity: 1; transition: transform 1s ease; }
    .effect-push.exit { transform: translateY(-100%); opacity: 1; transition: transform 1s ease; }
</style>
{% endblock %}

{% block extra_js %}
<!-- å¼•å…¥åº“ -->
<script src="https://cdn.jsdelivr.net/npm/lunar-javascript@1.6.12/lunar.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
    // ... existing JS preamble ...
    const API_BASE = '/api';
    let is24Hour = {{ 'true' if time_format == '24h' else 'false' }};
    const weatherLat = {{ weather_config.get('latitude', 39.73) }};
    const weatherLon = {{ weather_config.get('longitude', 116.33) }};

    // ... Date Time Logic ...
    function updateTime() {
        const now = new Date();
        let hours = now.getHours();
        const minutes = String(now.getMinutes()).padStart(2, '0');
        const seconds = String(now.getSeconds()).padStart(2, '0');
        let ampm = '';
        if (!is24Hour) {
            ampm = hours >= 12 ? ' PM' : ' AM';
            hours = hours % 12;
            hours = hours ? hours : 12;
        }
        hours = String(hours).padStart(2, '0');
        document.getElementById('time-display').textContent = `${hours}:${minutes}:${seconds}${ampm}`;
        const days = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
        document.getElementById('date-solar').textContent = 
            `${now.getFullYear()}/${now.getMonth()+1}/${now.getDate()} ${days[now.getDay()]}`;
        if (window.Lunar) {
            const lunar = Lunar.fromDate(now);
            document.getElementById('date-lunar-ganzhi').textContent = 
                `${lunar.getMonthInChinese()}æœˆ${lunar.getDayInChinese()} Â· ${lunar.getYearInGanZhi()}å¹´ [${lunar.getYearShengXiao()}]`;
        }
    }
    function toggleTimeFormat() { is24Hour = !is24Hour; updateTime(); }
    setInterval(updateTime, 1000);
    updateTime();

    // ... Weather Logic ...
    const weatherCodes = { 0:'â˜€ï¸',1:'ğŸŒ¤ï¸',2:'â›…',3:'â˜ï¸',45:'ğŸŒ«ï¸',48:'â„ï¸',51:'ğŸŒ§ï¸',53:'ğŸŒ§ï¸',55:'ğŸŒ§ï¸',61:'ğŸŒ§ï¸',63:'ğŸŒ§ï¸',65:'ğŸŒ§ï¸',80:'ğŸŒ¦ï¸',95:'â›ˆï¸' };
    async function updateWeather() {
        if (window.isAppSleeping) return;
        try {
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${weatherLat}&longitude=${weatherLon}&current=temperature_2m,weather_code&hourly=temperature_2m,weather_code&timezone=Asia%2FShanghai&forecast_days=3`;
            const res = await fetch(url);
            const data = await res.json();
            if (data.current) {
                const temp = Math.round(data.current.temperature_2m);
                const icon = weatherCodes[data.current.weather_code] || 'ğŸŒˆ';
                document.getElementById('weather-temp').textContent = `${temp}Â°C`;
                document.getElementById('weather-icon').textContent = icon;
            }
            if (data.hourly && data.hourly.time) {
                const now = new Date();
                const year = now.getFullYear();
                const month = String(now.getMonth() + 1).padStart(2, '0');
                const day = String(now.getDate()).padStart(2, '0');
                const hour = String(now.getHours()).padStart(2, '0');
                const currentHourStr = `${year}-${month}-${day}T${hour}`;
                let currentIndex = data.hourly.time.findIndex(t => t.startsWith(currentHourStr));
                if (currentIndex === -1) {
                    for(let i=0; i<data.hourly.time.length; i++) {
                        if (data.hourly.time[i] >= currentHourStr) {
                            currentIndex = i;
                            break;
                        }
                    }
                }
                if (currentIndex === -1) currentIndex = 0;
                const forecastContainer = document.getElementById('weather-forecast');
                forecastContainer.innerHTML = '';
                const offsets = [2, 4, 6, 12, 24];
                offsets.forEach(offset => {
                    const idx = currentIndex + offset;
                    if (idx < data.hourly.time.length) {
                        const timeStr = data.hourly.time[idx];
                        const temp = Math.round(data.hourly.temperature_2m[idx]);
                        const code = data.hourly.weather_code[idx];
                        const icon = weatherCodes[code] || 'â“';
                        const timeParts = timeStr.split('T');
                        const timeDisplay = timeParts.length > 1 ? timeParts[1] : timeStr;
                        const el = document.createElement('div');
                        el.className = 'forecast-item';
                        el.innerHTML = `<div class="forecast-time">${timeDisplay}</div><div class="forecast-icon">${icon}</div><div class="forecast-temp">${temp}Â°</div>`;
                        forecastContainer.appendChild(el);
                    }
                });
            }
        } catch (e) { console.error("å¤©æ°”é”™è¯¯", e); }
    }
    updateWeather();
    setInterval(updateWeather, 1800000);

    // ==================== 3. é‡‘èé€»è¾‘ (é‡æ„ç‰ˆ) ====================
    let chartInstances = {};
    let watchlist = [];
    let currentStockIndex = 0;
    const tickerSpeed = {{ finance_config.get('ticker_speed_seconds', 30) }};
    const stockSwitchInterval = {{ finance_config.get('stock_switch_interval_seconds', 10) }} * 1000;

    // å­˜å‚¨æŒ‡æ•°è¿·ä½ å›¾è¡¨å®ä¾‹
    let indexChartInstances = {};
    
    async function updateIndices() {
        if (window.isAppSleeping) return;
        try {
            const res = await fetch(`${API_BASE}/finance/indices`);
            const data = await res.json();
            const container = document.getElementById('indices-container');
            container.innerHTML = '';
            if (data.length === 0) {
                container.innerHTML = '<div style="color:#999; padding:10px;">æš‚æ— æŒ‡æ•°æ•°æ®</div>';
                return;
            }
            const track = document.createElement('div');
            track.className = 'indices-track';
            
            // åˆ›å»ºæŒ‡æ•°å¡ç‰‡HTMLï¼ˆè¯¦ç»†ç‰ˆ + è¶‹åŠ¿å›¾ï¼‰
            const createCardsHtml = (items, suffix = '') => {
                return items.map((idx, i) => {
                    const isUp = idx.change >= 0;
                    const colorClass = isUp ? 'up' : 'down';
                    const bgClass = isUp ? 'up-bg' : 'down-bg';
                    const sign = isUp ? '+' : '';
                    const canvasId = `index-chart-${idx.symbol.replace(/[^a-zA-Z0-9]/g, '')}-${suffix}-${i}`;
                    
                    return `
                        <div class="index-card ${bgClass}">
                            <div class="index-info">
                                <div class="index-name">${idx.name}</div>
                                <div class="index-price ${colorClass}">${idx.price.toFixed(2)}</div>
                                <div class="index-change-row">
                                    <span class="index-change-val ${colorClass}">${sign}${idx.change.toFixed(2)}</span>
                                    <span class="index-change-pct ${colorClass}">(${sign}${idx.change_percent.toFixed(2)}%)</span>
                                </div>
                            </div>
                            <div class="index-chart-box">
                                <canvas id="${canvasId}" data-history='${JSON.stringify(idx.history_1m || [])}'></canvas>
                            </div>
                        </div>
                    `;
                }).join('');
            };
            
            // æ— ç¼æ»šåŠ¨ï¼šå¤åˆ¶ä¸¤ä»½æ•°æ®
            track.innerHTML = createCardsHtml(data, 'a') + createCardsHtml(data, 'b');
            container.appendChild(track);
            track.style.animationDuration = `${tickerSpeed * 2}s`;  // å¡ç‰‡æ›´å¤§ï¼Œéœ€è¦æ›´å¤šæ—¶é—´
            
            // æ¸²æŸ“æ‰€æœ‰è¿·ä½ è¶‹åŠ¿å›¾
            setTimeout(() => {
                renderAllIndexCharts();
            }, 100);
            
        } catch (e) { console.error("æŒ‡æ•°æ›´æ–°å¤±è´¥", e); }
    }
    
    // æ¸²æŸ“æŒ‡æ•°è¿·ä½ è¶‹åŠ¿å›¾
    function renderAllIndexCharts() {
        // æ¸…ç†æ—§çš„å›¾è¡¨å®ä¾‹
        Object.values(indexChartInstances).forEach(chart => {
            if (chart) chart.destroy();
        });
        indexChartInstances = {};
        
        // æŸ¥æ‰¾æ‰€æœ‰è¿·ä½ å›¾è¡¨canvas
        const canvases = document.querySelectorAll('.index-chart-box canvas');
        canvases.forEach(canvas => {
            const canvasId = canvas.id;
            let historyData = [];
            try {
                historyData = JSON.parse(canvas.dataset.history || '[]');
            } catch(e) {}
            
            if (historyData.length > 0) {
                renderMiniChart(canvasId, historyData);
            }
        });
    }
    
    // æ¸²æŸ“å•ä¸ªè¿·ä½ è¶‹åŠ¿å›¾
    function renderMiniChart(canvasId, points) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        if (!points || points.length < 2) return;
        
        const values = points.map(p => p.v);
        const firstVal = values[0];
        const lastVal = values[values.length - 1];
        const isUp = lastVal >= firstVal;
        const lineColor = isUp ? '#e74c3c' : '#2ecc71';
        const fillColor = isUp ? 'rgba(231, 76, 60, 0.2)' : 'rgba(46, 204, 113, 0.2)';
        
        indexChartInstances[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: points.map(p => p.t),
                datasets: [{
                    data: values,
                    borderColor: lineColor,
                    backgroundColor: fillColor,
                    borderWidth: 1.5,
                    pointRadius: 0,
                    tension: 0.3,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false }, tooltip: { enabled: false } },
                scales: {
                    x: { display: false },
                    y: { display: false }
                },
                animation: { duration: 0 },
                elements: { line: { borderCapStyle: 'round' } }
            }
        });
    }

    async function loadWatchlist() {
        if (window.isAppSleeping) return;
        try {
            const res = await fetch(`${API_BASE}/finance/watchlist`);
            watchlist = await res.json();
            if (watchlist.length > 0) {
                loadNextStock();
                setInterval(loadNextStock, stockSwitchInterval); 
            } else {
                document.getElementById('stock-name').textContent = "æ— è‡ªé€‰è‚¡";
            }
        } catch (e) { console.error("è‡ªé€‰è‚¡åˆ—è¡¨å¤±è´¥", e); }
    }

    async function loadNextStock() {
        if (window.isAppSleeping) return;
        if (!watchlist || watchlist.length === 0) return;
        
        const stock = watchlist[currentStockIndex];
        currentStockIndex = (currentStockIndex + 1) % watchlist.length;
        
        try {
            const res = await fetch(`${API_BASE}/finance/stock/${stock.symbol}`);
            if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
            const data = await res.json();
            
            // Helper to safely set text content
            const setText = (id, text) => {
                const el = document.getElementById(id);
                if (el) el.textContent = text;
            };
            
            // Helper to safely set style
            const setStyle = (id, prop, val) => {
                const el = document.getElementById(id);
                if (el) el.style[prop] = val;
            };

            // 1. Header Info
            const isUp = (data.change || 0) >= 0;
            const color = isUp ? '#e74c3c' : '#2ecc71';
            const sign = isUp ? '+' : '';
            
            setText('stock-name', data.name || '--');
            setText('stock-symbol', data.symbol || '--');
            
            setText('stock-price', (data.price || 0).toFixed(2));
            setStyle('stock-price', 'color', color);

            const changeText = `${sign}${(data.change || 0).toFixed(2)} (${sign}${(data.change_percent || 0).toFixed(2)}%)`;
            setText('stock-change', changeText);
            setStyle('stock-change', 'color', color);

            // 2. Unified Target Logic & Badge
            const badge = document.getElementById('stock-type-badge');
            const targetLabel = document.getElementById('target-label');
            const holdingRow = document.getElementById('holding-info-row');

            let targetPrice = 0;
            let isBuyTarget = true;

            if (data.type === 'holding') {
                if(badge) { badge.textContent = 'æŒä»“'; badge.className = 'stock-badge badge-holding'; }
                if(holdingRow) holdingRow.style.display = 'flex';
                if(targetLabel) targetLabel.textContent = 'æ­¢ç›ˆç›®æ ‡';
                
                targetPrice = data.target_sell_price;
                isBuyTarget = false;
            } else {
                if(badge) { badge.textContent = 'è§‚å¯Ÿ'; badge.className = 'stock-badge badge-watching'; }
                if(holdingRow) holdingRow.style.display = 'none';
                if(targetLabel) targetLabel.textContent = 'ä¹°å…¥ç›®æ ‡';
                
                targetPrice = data.target_buy_price;
                isBuyTarget = true;
            }

            // Update Unified Target Display
            updateUnifiedTarget(targetPrice, data.price, isBuyTarget);

            // 3. Extra Info
            const low = (data.year_low || 0).toFixed(2);
            const high = (data.year_high || 0).toFixed(2);
            setText('metric-year-range', `${low}-${high}`);
            
            // Vol
            let volStr = '--';
            if (data.volume !== undefined && data.volume !== null) {
                if (data.volume > 1000000000) volStr = (data.volume / 1000000000).toFixed(2) + 'B';
                else if (data.volume > 1000000) volStr = (data.volume / 1000000).toFixed(2) + 'M';
                else if (data.volume > 1000) volStr = (data.volume / 1000).toFixed(1) + 'K';
                else volStr = data.volume.toString();
            }
            setText('metric-volume', volStr);
            
            setText('metric-prev-close', (data.prev_close || 0).toFixed(2));

            // Analyst
            const analystContainer = document.getElementById('metric-analyst-container');
            if (analystContainer) {
                if (data.analyst_target_price) {
                    analystContainer.style.display = 'block';
                    setText('metric-analyst-target', data.analyst_target_price.toFixed(2));
                } else {
                    analystContainer.style.display = 'none';
                }
            }
            
            // Earnings
            const earningsContainer = document.getElementById('metric-earnings-container');
            if (earningsContainer) {
                if (data.earnings_date) {
                    earningsContainer.style.display = 'block';
                    setText('metric-earnings', data.earnings_date);
                } else {
                    earningsContainer.style.display = 'none';
                }
            }

            // 4. Holding Gain Updates
            if (data.type === 'holding') {
                const gain = data.holding_gain || 0;
                const gainPct = data.holding_gain_percent || 0;
                
                const gainSign = gain > 0 ? '+' : '';
                setText('metric-holding-gain', `${gainSign}${gain.toFixed(0)}`);
                
                const pctSign = gainPct > 0 ? '+' : '';
                setText('metric-holding-percent', `${pctSign}${gainPct.toFixed(2)}%`);
                
                const gainColor = gain >= 0 ? '#e74c3c' : '#2ecc71';
                setStyle('metric-holding-gain', 'color', gainColor);
                setStyle('metric-holding-percent', 'color', gainColor);
            }

            // 5. Gauge
            updateGauge(data.price, data.target_buy_price, data.target_sell_price);

            // 6. Visual Feedback
            const container = document.getElementById('stock-carousel');
            if (container) {
                container.classList.remove('status-buy-zone', 'status-sell-zone');
                
                if (data.target_buy_price > 0 && data.price <= data.target_buy_price * 1.05) {
                     container.classList.add('status-buy-zone');
                } else if (data.target_sell_price > 0 && data.price >= data.target_sell_price * 0.95) {
                     container.classList.add('status-sell-zone');
                }
            }

            // 7. Chart
            renderChart('stockChartCycle', data.history_3y || [], data.ma_250 || [], color);
            
        } catch (e) { 
            console.error(`ä¸ªè‚¡ ${stock ? stock.name : 'unknown'} åŠ è½½å¤±è´¥:`, e); 
        }
    }
    
    function updateUnifiedTarget(target, current, isBuy) {
        const valEl = document.getElementById('metric-target-val');
        const diffEl = document.getElementById('metric-target-diff');
        
        if (!target || target === 0) {
            valEl.textContent = '--';
            diffEl.textContent = 'æœªè®¾ç½®';
            diffEl.className = 'target-diff neutral';
            diffEl.style.color = '#888';
            return;
        }
        
        valEl.textContent = target.toFixed(2);
        const diffPercent = ((current - target) / target) * 100;
        
        if (isBuy) {
            // Buy Target: Want current < target. diffPercent is negative is good.
            // Show "Dist +X%" or "Reached"
            const distText = diffPercent <= 0 ? 'å·²å‡»ç©¿' : `+${diffPercent.toFixed(1)}%`;
            diffEl.textContent = distText;
            // Green if close or reached
            diffEl.style.color = diffPercent <= 5 ? '#2ecc71' : '#aaa'; 
        } else {
            // Sell Target: Want current > target. diffPercent positive is good.
            const distText = diffPercent >= 0 ? 'å·²è¾¾æ ‡' : `${diffPercent.toFixed(1)}%`;
            diffEl.textContent = distText;
            // Red if close or reached
            diffEl.style.color = diffPercent >= -5 ? '#e74c3c' : '#aaa';
        }
    }

    function updateGauge(current, buy, sell) {
        if (!buy || !sell) return;
        const min = buy * 0.8;
        const max = sell * 1.2;
        const range = max - min;
        const getPos = (val) => {
            let pct = ((val - min) / range) * 100;
            return Math.max(0, Math.min(100, pct));
        };
        document.getElementById('gauge-marker-buy').style.left = getPos(buy) + '%';
        document.getElementById('gauge-marker-sell').style.left = getPos(sell) + '%';
        document.getElementById('gauge-cursor').style.left = getPos(current) + '%';
    }

    function renderChart(canvasId, points, maPoints, lineColor) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        if (chartInstances[canvasId]) chartInstances[canvasId].destroy();
        if (!points || points.length === 0) return;
        const labels = points.map(p => p.t);
        const data = points.map(p => p.v);
        const maData = maPoints ? maPoints.map(p => p.v) : [];
        chartInstances[canvasId] = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [
                    { label: 'Price', data: data, borderColor: lineColor, backgroundColor: 'rgba(0,0,0,0)', borderWidth: 1.5, pointRadius: 0, tension: 0.2 },
                    { label: 'MA50', data: maData, borderColor: 'rgba(255, 215, 0, 0.6)', borderWidth: 1, pointRadius: 0, borderDash: [5, 5], tension: 0.2 }
                ]
            },
            options: {
                responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false } },
                scales: {
                    x: { display: true, ticks: { color: '#555', font: {size: 9}, maxTicksLimit: 6 }, grid: { display: false } },
                    y: { display: true, position: 'right', grid: { color: 'rgba(255,255,255,0.05)' }, ticks: { color: '#555', font: {size: 9} } }
                }, animation: { duration: 0 }
            }
        });
    }

    // ... existing photo logic ...
    // ... existing sleep manager logic ...
    // (Keeping the rest of the file content identical to previous version, just modifying the parts above)
    
    // Note: To ensure the file write is complete and correct, I'm including the full file logic for the parts not modified in detail here implicitly by not changing them if I were to edit partially, but since `write` replaces the whole file, I must include everything.
    // I will paste the full content from previous read + modifications.
    
    // Re-pasting the full content of photo/sleep logic to be safe.
    
    // ... (Photo Logic) ...
    let photos = [];
    let currentPhotoIndex = 0;
    let slideshowInterval = null;
    const slideshowDelay = ({{ slideshow_interval_seconds|default(10) }}) * 1000;
    const showMetadata = {{ 'true' if show_metadata else 'false' }};
    const slideshowTransition = '{{ slideshow_transition|default("fade") }}';
    let currentChannel = '{{ default_channel|default("NASA TV") }}';

    async function loadYouTubeChannel(channelName) {
        try {
            const encoded = encodeURIComponent(channelName);
            const res = await fetch(`${API_BASE}/youtube/embed/${encoded}`);
            const data = await res.json();
            const iframe = document.getElementById('youtube-iframe');
            if (iframe && data.embed_url) {
                const urlObj = new URL(data.embed_url);
                urlObj.searchParams.set('autoplay', '1');
                urlObj.searchParams.set('mute', '1');
                urlObj.searchParams.delete('enablejsapi');
                iframe.src = urlObj.toString();
                iframe.style.display = 'block';
                document.getElementById('youtube-loading').style.display = 'none';
            }
        } catch(e) {}
    }

    async function loadPhotos() {
        try {
            const res = await fetch(`${API_BASE}/albums/slideshow`);
            photos = await res.json();
            const container = document.getElementById('photo-container');
            if (photos.length > 0) { 
                container.innerHTML = `
                    <div id="photo-stage" style="width:100%;height:100%;position:relative;" class="transition-${slideshowTransition}"></div>
                    <button class="photo-nav prev" onclick="prevPhoto()">â€¹</button>
                    <button class="photo-nav next" onclick="nextPhoto()">â€º</button>
                    <div id="photo-metadata-container" class="photo-metadata ${showMetadata ? '' : 'hidden'}"></div>
                `;
                displayPhoto(0); 
                startSlideshow(); 
            } else { 
                container.innerHTML = '<div class="error">æš‚æ— ç…§ç‰‡<br>è¯·åœ¨â€œè®¾ç½®â€ä¸­åˆ›å»ºç›¸å†Œå¹¶ä¸Šä¼ ç…§ç‰‡</div>'; 
            }
        } catch(e) { console.error("åŠ è½½ç…§ç‰‡å¤±è´¥", e); }
    }

    function displayPhoto(index) {
        if (photos.length === 0) return;
        currentPhotoIndex = index;
        const photo = photos[index];
        const stage = document.getElementById('photo-stage');
        if (!stage) return; 
        const wrapper = document.createElement('div');
        wrapper.className = 'photo-wrapper enter'; 
        let contentHtml = '';
        if (photo.type === 'video' || (photo.filename && photo.filename.match(/\.(mp4|mov)$/i))) {
             contentHtml = `<video src="${photo.url}" class="photo-video" autoplay muted loop playsinline style="max-width:100%;max-height:100%;"></video>`;
        } else {
             let src = photo.web_url || photo.url;
             const ts = photo.updated_at ? new Date(photo.updated_at).getTime() : (photo.created_at ? new Date(photo.created_at).getTime() : '');
             if (ts) src += (src.includes('?') ? '&' : '?') + `v=${ts}`;
             contentHtml = `<img src="${src}" class="photo-image" loading="eager">`;
        }
        wrapper.innerHTML = contentHtml;
        stage.appendChild(wrapper);
        wrapper.offsetHeight; 
        
        // Determine effect based on setting
        let effect = 'effect-fade';
        if (slideshowTransition === 'slide-left' || slideshowTransition === 'slide-right') effect = 'effect-slide-left';
        else if (slideshowTransition === 'slide-up' || slideshowTransition === 'slide-down') effect = 'effect-push';
        else if (slideshowTransition === 'zoom-in' || slideshowTransition === 'zoom-out') effect = 'effect-zoom';
        else if (slideshowTransition === 'none') effect = 'effect-fade'; // Fallback to fade for none, or could handle specifically
        
        wrapper.classList.add(effect);
        if (slideshowTransition === 'none') wrapper.style.transition = 'none';

        const oldActive = stage.querySelector('.photo-wrapper.active');
        if (oldActive) {
            oldActive.classList.remove('active');
            oldActive.classList.add('exit');
            oldActive.classList.add(effect); 
            
            // If 'none', remove immediately
            const delay = slideshowTransition === 'none' ? 0 : 1500;
            setTimeout(() => { if(oldActive.parentNode === stage) stage.removeChild(oldActive); }, delay); 
        }
        wrapper.classList.remove('enter');
        wrapper.classList.add('active');
        updateMetadata(photo, index);
        preloadNextPhoto(index);
    }
    
    function preloadNextPhoto(currentIndex) {
        if (photos.length <= 1) return;
        const nextIndex = (currentIndex + 1) % photos.length;
        const nextPhoto = photos[nextIndex];
        if (nextPhoto.type !== 'video' && (!nextPhoto.filename || !nextPhoto.filename.match(/\.(mp4|mov)$/i))) {
            let src = nextPhoto.web_url || nextPhoto.url;
            const ts = nextPhoto.updated_at ? new Date(nextPhoto.updated_at).getTime() : (nextPhoto.created_at ? new Date(nextPhoto.created_at).getTime() : '');
            if (ts) src += (src.includes('?') ? '&' : '?') + `v=${ts}`;
            const img = new Image();
            img.src = src;
        }
    }
    
    function updateMetadata(photo, index) {
        const metaContainer = document.getElementById('photo-metadata-container');
        if (!metaContainer) return;
        if (showMetadata) {
            metaContainer.classList.remove('hidden');
            metaContainer.style.display = 'block';
        } else {
            metaContainer.classList.add('hidden');
            metaContainer.style.display = 'none';
            return;
        }
        let primaryText = photo.album_name || 'æœªå‘½åç›¸å†Œ';
        let secondaryHtml = '';
        let timeStr = '';
        try {
            if (photo.date_taken) {
                let dt = photo.date_taken;
                if (typeof dt === 'string') dt = dt.replace(' ', 'T');
                const d = new Date(dt);
                if (!isNaN(d.getTime())) {
                    const datePart = d.toLocaleDateString('zh-CN', {year: 'numeric', month: '2-digit', day: '2-digit'}).replace(/\//g, '-');
                    const timePart = d.toLocaleTimeString('zh-CN', {hour: '2-digit', minute: '2-digit', hour12: false});
                    timeStr = `${datePart} ${timePart}`;
                } else { timeStr = String(photo.date_taken); }
            } else if (photo.created_at) {
                 const d = new Date(photo.created_at);
                 if (!isNaN(d.getTime())) timeStr = d.toLocaleDateString('zh-CN').replace(/\//g, '-');
            }
        } catch(e) {}
        if (timeStr) secondaryHtml += `<div class="meta-item"><img src="/static/icons/calendar.svg" class="meta-icon-img"> ${timeStr}</div>`;
        try {
            if (photo.model) {
                const make = photo.make ? String(photo.make).replace(/\0/g, '').trim() : '';
                const model = String(photo.model).replace(/\0/g, '').trim();
                let device = model;
                if (make && !model.toLowerCase().includes(make.toLowerCase())) device = `${make} ${model}`;
                if (device) secondaryHtml += `<div class="meta-item"><img src="/static/icons/camera.svg" class="meta-icon-img"> ${device}</div>`;
            }
        } catch(e) {}
        try {
            if (photo.location_name) secondaryHtml += `<div class="meta-item"><img src="/static/icons/location.svg" class="meta-icon-img"> ${photo.location_name}</div>`;
            else if (photo.has_location) secondaryHtml += `<div class="meta-item"><img src="/static/icons/location.svg" class="meta-icon-img">åŒ…å«ä½ç½®ä¿¡æ¯</div>`;
        } catch(e) {}
        metaContainer.innerHTML = `<div class="meta-primary"><img src="/static/icons/folder.svg" class="meta-icon-img"> ${primaryText}</div><div class="meta-secondary">${secondaryHtml}</div><div class="meta-counter">${index + 1} / ${photos.length}</div>`;
    }
    
    function prevPhoto() {
        if (photos.length === 0) return;
        currentPhotoIndex = (currentPhotoIndex - 1 + photos.length) % photos.length;
        displayPhoto(currentPhotoIndex);
        resetSlideshow();
    }
    function nextPhoto() {
        if (photos.length === 0) return;
        currentPhotoIndex = (currentPhotoIndex + 1) % photos.length;
        displayPhoto(currentPhotoIndex);
        resetSlideshow();
    }
    function startSlideshow() {
        if (slideshowInterval) clearInterval(slideshowInterval);
        slideshowInterval = setInterval(() => { nextPhoto(); }, slideshowDelay);
    }
    function resetSlideshow() {
        if (slideshowInterval) clearInterval(slideshowInterval);
        startSlideshow();
    }
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowLeft') { prevPhoto(); }
        else if (e.key === 'ArrowRight') { nextPhoto(); }
        else if (e.key === 'Escape') { if (document.fullscreenElement) document.exitFullscreen(); }
    });
    window.addEventListener('DOMContentLoaded', () => {
        window.isAppSleeping = false; // åˆå§‹åŒ–ç¡çœ çŠ¶æ€
        if (currentChannel) loadYouTubeChannel(currentChannel);
        loadPhotos();
        initSleepManager();
        
        // å¯åŠ¨é‡‘èæ•°æ®æ›´æ–°
        updateIndices();
        loadWatchlist();
        // å®šæ—¶æ›´æ–°æŒ‡æ•° (æ¯5åˆ†é’Ÿ)
        setInterval(updateIndices, 300000);
    });

    function initSleepManager() {
        let configEnabled = {{ 'true' if energy_config.get('enabled', True) else 'false' }};
        let configStartTime = "{{ energy_config.get('start_time', '22:30') }}";
        let configEndTime = "{{ energy_config.get('end_time', '05:30') }}";
        let isSleeping = false;
        let sleepInterval = null;
        let pixelShiftInterval = null;
        const parseTime = (t) => {
            if (!t) return 0;
            const [h, m] = t.split(':').map(Number);
            return h * 60 + m;
        };
        const syncConfig = async () => {
            try {
                const res = await fetch(`${API_BASE}/settings/`);
                if (!res.ok) return;
                const data = await res.json();
                configEnabled = data.energy_enabled;
                configStartTime = data.energy_start_time;
                configEndTime = data.energy_end_time;
                checkSleep();
            } catch (e) { console.error("é…ç½®åŒæ­¥å¤±è´¥", e); }
        };
        const checkSleep = () => {
            if (!configEnabled) {
                if (isSleeping) exitSleep();
                return;
            }
            const now = new Date();
            const currMins = now.getHours() * 60 + now.getMinutes();
            const startMins = parseTime(configStartTime);
            const endMins = parseTime(configEndTime);
            let shouldSleep = false;
            if (startMins > endMins) shouldSleep = (currMins >= startMins) || (currMins < endMins);
            else shouldSleep = (currMins >= startMins) && (currMins < endMins);
            if (shouldSleep && !isSleeping) enterSleep();
            else if (!shouldSleep && isSleeping) exitSleep();
        };
        const enterSleep = () => {
            isSleeping = true;
            document.getElementById('sleep-overlay').style.display = 'flex';
            const iframe = document.getElementById('youtube-iframe');
            if (iframe) iframe.src = '';
            if (slideshowInterval) clearInterval(slideshowInterval);
            window.isAppSleeping = true;
            pixelShiftInterval = setInterval(() => {
                const content = document.querySelector('.sleep-content');
                const x = Math.floor(Math.random() * 100) - 50; 
                const y = Math.floor(Math.random() * 100) - 50;
                content.style.transform = `translate(${x}px, ${y}px)`;
            }, 60000 * 5); 
            updateSleepClock();
        };
        const exitSleep = () => {
            isSleeping = false;
            window.isAppSleeping = false;
            document.getElementById('sleep-overlay').style.display = 'none';
            if (currentChannel) loadYouTubeChannel(currentChannel);
            startSlideshow();
            updateIndices();
            updateWeather();
            if (pixelShiftInterval) clearInterval(pixelShiftInterval);
        };
        const updateSleepClock = () => {
            const now = new Date();
            const h = String(now.getHours()).padStart(2, '0');
            const m = String(now.getMinutes()).padStart(2, '0');
            const s = String(now.getSeconds()).padStart(2, '0');
            document.getElementById('sleep-time').textContent = `${h}:${m}:${s}`;
            const days = ['å‘¨æ—¥', 'å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­'];
            document.getElementById('sleep-date-full').textContent = `${now.getFullYear()}å¹´${String(now.getMonth()+1).padStart(2,'0')}æœˆ${String(now.getDate()).padStart(2,'0')}æ—¥ ${days[now.getDay()]}`;
            if (window.Lunar) {
                const lunar = Lunar.fromDate(now);
                document.getElementById('sleep-lunar').textContent = `${lunar.getMonthInChinese()}æœˆ${lunar.getDayInChinese()} Â· ${lunar.getYearInGanZhi()}å¹´ [${lunar.getYearShengXiao()}å¹´]`;
            }
        };
        if (sleepInterval) clearInterval(sleepInterval);
        sleepInterval = setInterval(() => { if (isSleeping) updateSleepClock(); }, 1000);
        setInterval(checkSleep, 1000);
        setInterval(syncConfig, 5000);
        checkSleep();
    }
</script>
{% endblock %}
